# 스프링 삼각형과 설정 정보
스프링 삼각형이란 IoC, AOP, PSA 세 가지 핵심 개념을 의미한다.

## IoC
Inversion of Control. 제어의 역전은 DI, Dependency Injection, 의존성 주입과 같이 다루어지는 경우가 많다.
자바 객체의 의존성은 크게 두 가지로 나눌 수 있는데 집합(aggregation)과 구성(composition)이다. 확실한 차이는 집합 관계의 객체들은 서로 다른 생명 주기를 가질 수 있지만
구성 관계의 객체들은 동일한 생명 주기를 가진다. 즉 구성 관계의 객체들은 생성될 때 같이 생성되서 의존하고 소멸할 때 같이 소멸한다는 것이다.

의존성 주입 없이 다른 자바 객체를 의존할 때는 외부에서 주입받지 않는 이상 `new` 연산자로 해당 객체를 의존하게 되며 이 경우 해당 의존 객체를 생성자에서 생성하는 식으로
'구성' 관계를 갖게 된다. 즉 A 객체를 생성할 때 B 객체를 생성하여 같이 생성되고 소멸할 때도 같이 소멸하는 같은 생명주기를 가지는 구성 관계인 것이다.

그렇다면 의존성을 직접 생성하지 않고 외부에서 주입받는다면 어떨까? 가장 흔한 방법은 생성자나 setter 메서드로 외부에서 의존 객체를 주입받아 내부 필드에서 참조하는 방법이다.
이 경우 우리는 `new` 연산자로 직접적으로 의존할 필요가 없으며 주입받는 객체 역시 현재 객체의 생성과 소멸에 관계가 없기 때문에 다른 생명주기를 가지는 '집합' 관계가 된다.

이런 집합 관계는 무슨 장점이 있을까? 만약 구현 클래스가 아니라 추상 클래스나 인터페이스 타입으로 의존받는다면 유연하게 의존성을 변경할 수 있다.
그리고 어떤 의존성을 사용할 지 결정하는 부분을 현재 클래스가 아니라 외부(구현체를 생성하여 주입시켜주는 조립자 등)에게 위임하여 책임을 분리할 수 있다는 장점이 있다.

스프링에서는 이런 의존성 주입을 XML 파일이나 Java 설정 클래스를 통해 수행할 수 있다. XML 파일에서는 Bean 객체를 의존성 항목으로 등록하는 식으로 주입할 수 있고
Java 클래스에서는 생성자, setter 메서드, 필드 세 가지 방식으로 의존성을 주입할 수 있다. Java 방식에서는 생성자 주입 방식을 권장하는데 한 번 주입한 의존성은 변경될 일이 거의 없기 때문에
별도의 setter 메서드를 제공하지 않도록 하여 의존성의 불변을 보장하고 의존성의 크기(얼마나 다른 클래스에 의존하는지)를 알아보기 쉽기 때문이다. 그리고 테스트 코드를 작성할 때도
상황에 따라 스프링에서 주입받지 않고 직접 생성자로 의존성을 주입시킬 수도 있다는 장점이 있다.

중요한 것은 어떤 방식으로 주입하던지 간에 사용자는 직접 의존 객체를 생성해서 주입할 필요가 없다. 왜냐면 스프링이 컨테이너에 등록된 Bean 객체들을 조회해서 
위에서 선택한 주입 방식으로 주입하여 의존성을 채워주기 때문이다. 이런 과정을 의존성 주입(DI)이라 하며 의존성을 주입하는 주체가 개발자가 아닌 프레임워크가 됐기 때문에 
제어의 역전(IoC)이라고 하는 것이다.

## @Autowired / @Resource
스프링에서는 `@Autowired`로 의존성을 주입할 때 특정 인터페이스를 구현하거나 해당 클래스의 객체가 컨테이너에 단 하나만 있다면 해당 Bean 객체를 활용한다.
하지만 같은 타입의 객체가 여러 개 있다면 객체의 식별자(id)를 이용하여 찾는다. 즉 타입이 더 우선순위가 높다고 할 수 있다.

반대로 Java 표준 어노테이션인 `@Resource` 에서는 객체의 식별자를 이용하여 먼저 찾고 찾을 수 없다면 타입으로 찾는 방식이다. `@Autowired` 에서는 `@Qualifier` 어노테이션을
이용하여 식별자를 지정할 수 있었다면 `@Resource` 어노테이션은 식별자로 찾기 때문에 어노테이션 속성에서 지정할 수 있다.

중요한 것은 두 어노테이션 모두 Bean 객체의 식별자를 맞게 지정하고 일치하는 타입을 가질 경우 정상적으로 의존성을 찾아 주입받을 수 있지만
식별자가 없고 같은 타입의 Bean 객체들이 있다던가 식별자가 일치하더라도 같은 타입이 아닌 경우 정상적으로 주입받을 수 없다는 것 역시 동일하다.

