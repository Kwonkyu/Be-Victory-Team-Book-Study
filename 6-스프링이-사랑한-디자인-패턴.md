# 스프링이 사랑한 디자인 패턴
객체 지향의 특성과 설계 원칙을 알았다면 이를 활용하여 실제로 애플리케이션을 작성할 때 특정 문제 상황에서 어떤 식으로 코딩해서 해결할 수 있는지 best practices를 모아둔 것이 디자인 패턴이다.

개발하다보면 자주 겪는 문제를 여러 개발자들이 경험하고 코딩한 것을 기반으로 최적의 솔루션을 만들어둔 것이기 때문에 권장사항이지 필수사항은 아니다.

단순히 문제를 해결하는 것 외에도 일종의 '청사진'처럼 활용해서 어떤 문제에 대한 해결 방법을 직접 코드를 설명하지 않아도 개발자들끼리 이해할 수 있는 방식으로 설명할 수 있다.

[refactoring.guru](https://refactoring.guru/design-patterns)
## 어댑터 패턴
서로다른 인터페이스의 클래스가 통신할 수 있도록 어댑터 클래스를 작성하는 디자인 패턴.
![image](https://refactoring.guru/images/patterns/diagrams/adapter/problem-en-2x.png)
위처럼 서로 호환되지 않는 두 클래스끼리 통신하려면 둘 중 하나를 수정하거나 중간에서 누군가 포맷을 맞춰줘야 한다. 하지만 한 클래스의 인터페이스를 수정했을 때 이를 사용하는 다른 클라이언트가
영향을 받을 수 있어 OCP 원칙에 따라 변화에는 닫혀 있는 편이 좋다. 

이 뿐 아니어도 직접 수정할 수 없는 클래스(라이브러리 등)의 경우에도 적용하기 어렵기 때문에 중간에 어댑터 클래스를 두고
변환해서 전달하는 것이 더 좋을 것이다.
![image](https://refactoring.guru/images/patterns/diagrams/adapter/structure-object-adapter-2x.png)
어댑터 클래스는 위처럼 adaptee, 변환된 값을 전달받을 클래스(Service)를 내부에 포함(composition)하고 값을 변환할 클래스(Client)와 같은 인터페이스를 구현하는 방식으로 디자인할 수 있다.
그러면 코드를 작성할 때 서비스와 호환되지 않는 클라이언트 대신 같은 인터페이스의 호환되는 어댑터 클래스를 활용해서 서비스와 통신할 수 있다. 간단한 예시를 보이면 다음과 같다.

예를 들어 어떤 Xml 객체를 출력하는 인터페이스를 클라이언트가 다음처럼 구현하고 있다고 해 보자.
```java
// CLIENT
public class LegacyWriter implements XmlWriter {
    @Override
    public String write(Xml xml) {
        return String.format("<%s>%s</%s>", xml.tag, xml.value, xml.tag);
    }
}
```
이 클라이언트는 Xml 클래스만 받기 때문에 Json 클래스를 출력할 수 없다. 대신 Json 클래스를 출력할 수 있는 서비스는 다음처럼 정의되어 있다.
```java
// SERVICE
public class LatestWriter {
    public String write(Json json) {
        return String.format("{%s:'%s'}", json.key, json.value);
    }
}
```

이 두 클래스를 수정하지 않고 연결하려면 다음처럼 어댑터 클래스를 작성할 수 있다.
```java
public class WriterAdapter implements XmlWriter {
    private final LatestWriter jsonWriter;

    public WriterAdapter(LatestWriter jsonWriter) {
        this.jsonWriter = jsonWriter;
    }

    @Override
    public String write(Xml xml) {
        Json convertedJson = new Json(xml.tag, xml.value);
        return jsonWriter.write(convertedJson);
    }
}
```
언급했듯이 클라이언트의 인터페이스(`XmlWriter`)를 구현하면서 서비스 객체(`LatestWriter`)를 포함하여 두 클래스를 연결해서 사용하는 것을 볼 수 있다. 
그럼 클라이언트 코드(개발자) 측에서는 다음처럼 사용할 수 있다.
```java
public class Main {
    public static void main(String[] args) {
        LegacyWriter client = new LegacyWriter();
        Xml xml = new Xml("parameter", "username");
        System.out.println(client.write(xml));
        // service.write(xml); <-- incompatible.

        LatestWriter service = new LatestWriter();
        WriterAdapter adapter = new WriterAdapter(service);
        System.out.println(adapter.write(xml)); // <-- compatible by adapter.
    }
}
```
이 경우 출력값은 아래와 같다.
```
<parameter>username</parameter>
{parameter:'username'}
```
원하는 대로 두 클래스의 수정 없이 연결한 것을 볼 수 있다.

## 프록시 패턴
프록시 패턴은 원본 객체에 대한 접근을 제어하는 디자인 패턴이다. 클라이언트 측에서는 프록시 객체와 원본 객체를 구분할 수 없어야 하며 요청, 응답은 원본 객체와 동일해야 한다.
이를 위해서 원본 객체의 인터페이스를 분리해서 프록시 객체가 구현하는 방식을 활용할 수 있다.
![image](https://refactoring.guru/images/patterns/diagrams/proxy/structure-2x.png)

프록시 패턴은 여러 장점이 있는데 단순히 객체에 대한 접근을 제어하는 것 뿐 아니라 객체 호출 전후에 특별한 비즈니스 로직을 추가할 수도 있고 초기화에 시간이 오래 걸리는 자원은
실제 호출 시 lazy하게 초기화하도록 미룰 수도 있다. 아니면 한 번 접근했던 데이터는 다음 접근 시 캐싱을 활용해서 효율적으로 활용할 수 있다.
그러면서도 원본 객체는 변할 필요가 없는 OCP가 이 프록시 패턴의 장점이라 할 수 있다.
```java
public class SecretData implements DataRetrievable {
    @Override
    public String getData(String connection) {
        return "SENSITIVE_DATA";
    }
}
```
예를 들어 민감한 정보를 반환하는 객체가 있다고 하자. 이 객체에 대한 접근을 기록하기 위해 기능을 추가하려면 해당 클래스를 변경하는 것이 처음 떠오르는 해결 방법이지만
역시 OCP를 준수하려면 여기서 프록시 객체를 생성해서 사용할 수 있다.
```java
public class SecretDataProxy implements DataRetrievable {
    private final SecretData data;

    public SecretDataProxy(SecretData data) {
        this.data = data;
    }

    @Override
    public String getData(String connection) {
        System.out.printf("Secret data accessed at %s%n", LocalDateTime.now());
        String data = this.data.getData(connection);
        System.out.printf("Secret data retrieved at %s%n", LocalDateTime.now());
        return data;
    }
}
```
클라이언트 코드에서는 다음처럼 프록시 객체를 원본 객체와 동일하게 다룰 수 있다.
```java
public class Main {
    public static void main(String[] args) {
        DataRetrievable proxiedData = new SecretDataProxy(new SecretData());
        System.out.println(proxiedData.getData("jdbc_url_here"));
        System.out.println("");

        DataRetrievable normalData = new SecretData();
        System.out.println(normalData.getData("jdbc_url_here"));
    }
}
```
실행 결과는 다음과 같다.
```
Secret data accessed at 2021-11-01T12:36:57.267611700
Secret data retrieved at 2021-11-01T12:36:57.286611700
SENSITIVE_DATA

SENSITIVE_DATA
```
프록시 객체와 원본 객체 둘 다 `DataRetrievable` 인터페이스로 동일하게 사용했지만 프록시 객체는 추가된 로깅 기능이 적용된 것을 볼 수 있다.

상속으로 비슷하게 해결할 수 있는 문제가 아닌가 싶기도 하지만 프록시 패턴은 원본 객체의 전체적인 생명 주기를 관리하는 구성(composition) 방식을 사용하며 
lazy 초기화나 캐싱같은 문제는 상속이 해결할 수 없다는 차이가 있다.

위의 코드에서는 클라이언트가 직접 원본 객체를 생성해서 프록시 객체로 전달하는 방식을 사용했지만 실제로는 프록시 객체가 직접 원본 객체를 생성하는 방식을 사용할 수도 있다.
프록시 패턴과 유사한 데코레이터 패턴과의 가장 큰 차이점이 바로 이 점인데 데코레이터 패턴은 항상 클라이언트가 객체를 생성해서 주입시키는 방식이다.
[링크1](https://refactoring.guru/design-patterns/proxy), [링크2](https://stackoverflow.com/questions/18618779/differences-between-proxy-and-decorator-pattern/60478875)

## 데코레이터 패턴
데코레이터 패턴은 원본 객체를 감싸는 다른 객체를 만들어서 기능을 덧붙여가는 방식으로 추가하는 디자인 패턴이다. 프록시 패턴과 다른점은 프록시 객체는 원본 객체의 응답값을 건드리지 않지만
데코레이터 패턴에서는 기능 추가로 인해 충분히 변경될 수 있다는 점이다.
![image](https://refactoring.guru/images/patterns/diagrams/decorator/structure-2x.png)

프록시 패턴처럼 이 데코레이터 객체를 사용하는 클라이언트 측에서는 얼마나 많은 데코레이터 객체로 원본 객체가 감싸져 있던 간에 동일한 원본 객체처럼 다룰 수 있어야 한다. 
이 점이 일반 래퍼 클래스와 데코레이터 클래스의 차이점이며 이를 구현하기 위해 자바의 인터페이스를 활용할 수 있다.
```java
public class SimplePrinter implements Printer {
    @Override
    public String print(String name) {
        return name;
    }
}
```
단순한 문자열을 출력하는 `Printer` 인터페이스가 있을 때 원본 객체 `SimplePrinter`는 이를 구현하여 문자열을 반환하고 있다.
```java
public class SimplePrinter implements Printer {
    @Override
    public String print(String name) {
        return name;
    }
}
```
이 `SimplePrinter`를 꾸미는 데코레이터 클래스는 다음처럼 `Printer` 인터페이스를 구현하고 꾸밀 원본 객체(또는 데코레이터 객체)에 대한 참조를 내부 필드에 보관하는 식으로 디자인할 수 있다.
```java
import java.time.LocalDateTime;

public class TimeStampDecorator implements Printer {
    private final Printer printer;

    public TimeStampDecorator(Printer printer) {
        this.printer = printer;
    }

    @Override
    public String print(String name) {
        String innerResult = printer.print(name);
        return String.format("%s: %s", LocalDateTime.now(), innerResult);
    }
}
```
```java
public class NameDecorator implements Printer {
    private final Printer printer;

    public NameDecorator(Printer printer) {
        this.printer = printer;
    }

    @Override
    public String print(String name) {
        String innerResult = printer.print(name);
        return String.format("%s the Great", innerResult);
    }
}
```
```java
public class GreetingDecorator implements Printer {
    private final Printer printer;

    public GreetingDecorator(Printer printer) {
        this.printer = printer;
    }

    @Override
    public String print(String name) {
        String innerResult = printer.print(name);
        return String.format("Hello, %s!", innerResult);
    }
}
```
이런 식으로 디자인한 후 클라이언트 코드에서 다음처럼 적용시키면 데코레이터 클래스의 기능이 원본 객체에 중첩되서 적용된 것을 볼 수 있다.
```java
public class Main {
    public static void main(String[] args) {
        String name = "Kwonkyu";
        Printer simplePrinter = new SimplePrinter();
        Printer nameDecorator = new NameDecorator(simplePrinter);
        Printer greetDecorator = new GreetingDecorator(nameDecorator);
        Printer timestampDecorator = new TimeStampDecorator(greetDecorator);

        System.out.println(timestampDecorator.print(name));
        System.out.println(greetDecorator.print(name));
        System.out.println(nameDecorator.print(name));
        System.out.println(simplePrinter.print(name));
    }
}
```
실행 결과는 다음과 같다.
```
2021-11-01T14:20:57.201488600: Hello, Kwonkyu the Great!
Hello, Kwonkyu the Great!
Kwonkyu the Great        
Kwonkyu
```
필요에 따라 데코레이터 클래스를 추가하거나 삭제하는 것으로 객체의 기능을 유연하게 변경할 수 있으며 이는 고정된 부모 클래스의 기능을 가지는 상속과 구성(composition)의 차이점이라 할 수 있다.
역시 원본 클래스를 변경할 필요 없이 기능을 추가할 수 있기 때문에 OCP를 준수한다.

## 싱글턴 패턴
싱글턴 디자인 패턴은 어떤 클래스의 객체를 애플리케이션 전체에 통틀어서 단 하나만 생성하도록 디자인하는 패턴이다.
![image](https://refactoring.guru/images/patterns/diagrams/singleton/structure-en-2x.png)

간단히 어떤 클래스의 객체를 내부 필드로 관리하는 싱글턴 클래스를 디자인해서 원본 객체는 이 싱글턴 클래스 외에는 생성되지 못하도록 private 생성자를 적용한다. 그리고 정적 메서드를 통해
해당 클래스의 인스턴스를 반환하도록 구현할 수 있다. 
```java
public class DatabaseAccess {
    private final String jdbcUrl;
    private final LocalDateTime createdAt;
    private static DatabaseAccess databaseAccess;

    private DatabaseAccess(String jdbcUrl) {
        this.jdbcUrl = jdbcUrl;
        this.createdAt = LocalDateTime.now();
    }

    public static DatabaseAccess getInstance(String jdbcUrl) {
        if (databaseAccess == null) {
            databaseAccess = new DatabaseAccess(jdbcUrl);
        }
        return databaseAccess;
    }

    public String getJdbcUrl() {
        return jdbcUrl;
    }

    public LocalDateTime getCreatedAt() {
        return createdAt;
    }
}
```
클라이언트 코드 측에서는 다음처럼 사용할 수 있다.
```java
public class Main {
    public static void main(String[] args) {
        // DatabaseAccess access = new DatabaseAccess(); <== undefined
        // DatabaseAccess access = new DatabaseAccess("JDBC_URL_HERE"); <== not visible
        DatabaseAccess access1 = DatabaseAccess.getInstance("JDBC_URL_HERE");
        DatabaseAccess access2 = DatabaseAccess.getInstance("JDBC_URL_HERE");

        System.out.printf("Access1: %s / %s%n", access1.getJdbcUrl(), access1.getCreatedAt());
        System.out.printf("Access2: %s / %s%n", access2.getJdbcUrl(), access2.getCreatedAt());

        System.out.printf("Access1 == Access2: %s", access1 == access2);
    }
}
```
출력 결과는 다음과 같다.
```
Access1: JDBC_URL_HERE / 2021-11-01T15:22:55.154223400
Access2: JDBC_URL_HERE / 2021-11-01T15:22:55.154223400
Access1 == Access2: true
```
본래 자바 객체라면 매번 생성할 때마다 다른 메모리 영역(힙)에 위치하기 때문에 '==' 연산으로는 절대 같은 값이 나오지 않는다.
그러나 싱글턴 객체는 한 번 생성된 객체를 다시 가져오는 방식이기 때문에 같은 객체에 대한 '==' 연산으로 취급되어 `true`가 나오는 것이다.

싱글턴 패턴으로 특정 객체를 사용한다는 것은 대부분 여러 스레드에서 동시에 읽는 것이기 때문에 상태를 가지지 않도록 읽기 전용 필드만 두는 식으로 디자인해야 한다.
스프링의 Bean 객체가 이런 싱글턴으로 멀티 스레드에 의해 활용되기 때문에 유사한 특성을 가진다. 그러나 스프링의 싱글턴은 같은 식별자의 Bean 객체가 존재하지 않도록 하는 것이지
한 클래스의 객체가 하나만 생성되도록 강제하는 것이 아니라는 차이가 있다.

싱글턴 클래스가 내부 필드로 객체를 초기화하는 방법은 위처럼 필드의 `null` 상태를 확인하는 것 말고도 클래스 로딩 시점에 생성하는 방식이 있다.
```java
public class CreateAtFirst {
    private final static CreateAtFirst createAtFirst = new CreateAtFirst();

    private CreateAtFirst() {
    }

    public static CreateAtFirst getInstance() {
        return createAtFirst;
    }
}
```
이 방식은 멀티스레딩 환경에서 더 안전한데 왜냐면 처음 방식처럼 `getInstance` 메서드에서 `null` 상태를 확인하고 객체를 생성하는 로직은 분기 중간에 다른 스레드에게 주도권이 넘어갈 수 있어
두 스레드가 아직 객체가 생성되지 않았다고 판단해서 각자 새로운 객체를 생성할 수 있기 때문이다. 그래서 이런 동기화를 `synchronized`와 `volatile`로 해결할 수 있다는 [포스트](https://medium.com/swlh/java-singleton-pattern-and-synchronization-32665cbf6ad7)도 있으니 한 번 읽어보는 것도 좋을 것 같다. 

싱글턴 클래스는 자기 자신의 역할 뿐 아니라 객체가 하나만 생성되도록 제어하는 역할을 수행하기 때문에 SRP를 위반한다는 단점이 있다.

## 템플릿 메서드 패턴
어떤 클래스의 동작(알고리즘)을 단계별로 분할해서 부분적으로 재정의하고 이를 템플릿 메서드로 합쳐서 사용할 수 있는 디자인 패턴이다.

![image](https://refactoring.guru/images/patterns/diagrams/template-method/structure-2x.png)

위의 그림처럼 특정 메서드를 조합해서 동작하는 클래스가 있을때 클라이언트가 필요한 메서드만 재정의해서 구성 요소를 변경할 수 있는 것이다.
```java
public abstract class MailWriter {
    StringBuilder sb = new StringBuilder();

    public void writeGreeting() {
        sb.append("Hello! ");
    }

    public abstract void writeReceiver(String name);

    public void writeText(String text) {
        sb.append(System.lineSeparator());
        sb.append(text);
        sb.append(System.lineSeparator());
    }

    public void writeEnding(String sender) {
        sb.append(System.lineSeparator());
        sb.append("Sincerely, " + sender);
        sb.append(System.lineSeparator());
    }

    public void writePs() {
    }

    public String writeMail(String name, String sender, String text) {
        writeGreeting();
        writeReceiver(name);
        writeText(text);
        writeEnding(sender);
        writePs();
        return sb.toString();
    }
}
```
위처럼 메서드를 조합해서 편지를 쓰는 클래스가 있을 때 `writeMail` 메서드가 템플릿 메서드가 된다. 그리고 재정의 가능한 메서드는 두 가지 타입으로 정의할 수 있는데
하나는 `abstract` 키워드로 재정의를 강제하는 추상 메서드(`writeReceiver`)와 몸체는 구현되어 있고 선택적으로 재정의하는 Hook 메서드(`writePs`)가 있다.

**궁금한 점: 부모 타입으로 참조해도 Hook 메서드는 자식 타입으로 알아서 참조하던데 어떻게 동작하는 건지?(자바 구조적인 부분일지도...)**

```java
public class LightWriter extends MailWriter {
    @Override
    public void writeReceiver(String name) {
        super.sb.append(String.format("%s the great!", name));
    }

    @Override
    public void writePs() {
        super.sb.append("Don't forget to bring my umbrella back!");
    }
}
```
그리고 실제로 구현해서 사용할 때는 위처럼 간단하게 필요한 부분(또는 강제된 부분)만 재정의해서 구성 요소를 변화시킬 수 있다.
```java
public class Main {
    public static void main(String[] args) {
        MailWriter mw = new LightWriter();
        System.out.println(mw.writeMail("Jason", "Phillip", "Tomorrow will be another day."));
    }
}
```
위의 코드를 실행시키면 다음처럼 재정의된 부분이 반영된 것을 볼 수 있다.
```
Hello! Jason the great!
Tomorrow will be another day.

Sincerely, Phillip
Don't forget to bring my umbrella back!
```
이런 클래스는 여러개를 정의해서 자유롭게 기능을 재정의할 수 있으며 그러면서도 원본 클래스는 변하지 않기 때문에 OCP를 준수한다고 할 수 있다.
