# 스프링이 사랑한 디자인 패턴
객체 지향의 특성과 설계 원칙을 알았다면 이를 활용하여 실제로 애플리케이션을 작성할 때 특정 문제 상황에서 어떤 식으로 코딩해서 해결할 수 있는지 best practices를 모아둔 것이 디자인 패턴이다.

개발하다보면 자주 겪는 문제를 여러 개발자들이 경험하고 코딩한 것을 기반으로 최적의 솔루션을 만들어둔 것이기 때문에 권장사항이지 필수사항은 아니다.

단순히 문제를 해결하는 것 외에도 일종의 '청사진'처럼 활용해서 어떤 문제에 대한 해결 방법을 직접 코드를 설명하지 않아도 개발자들끼리 이해할 수 있는 방식으로 설명할 수 있다.

[refactoring.guru](https://refactoring.guru/design-patterns)
## 어댑터 패턴
서로다른 인터페이스의 클래스가 통신할 수 있도록 어댑터 클래스를 작성하는 디자인 패턴.
![image](https://refactoring.guru/images/patterns/diagrams/adapter/problem-en-2x.png)
위처럼 서로 호환되지 않는 두 클래스끼리 통신하려면 둘 중 하나를 수정하거나 중간에서 누군가 포맷을 맞춰줘야 한다. 하지만 한 클래스의 인터페이스를 수정했을 때 이를 사용하는 다른 클라이언트가
영향을 받을 수 있어 OCP 원칙에 따라 변화에는 닫혀 있는 편이 좋다. 

이 뿐 아니어도 직접 수정할 수 없는 클래스(라이브러리 등)의 경우에도 적용하기 어렵기 때문에 중간에 어댑터 클래스를 두고
변환해서 전달하는 것이 더 좋을 것이다.
![image](https://refactoring.guru/images/patterns/diagrams/adapter/structure-object-adapter-2x.png)
어댑터 클래스는 위처럼 adaptee, 변환된 값을 전달받을 클래스(Service)를 내부에 포함(composition)하고 값을 변환할 클래스(Client)와 같은 인터페이스를 구현하는 방식으로 디자인할 수 있다.
그러면 코드를 작성할 때 서비스와 호환되지 않는 클라이언트 대신 같은 인터페이스의 호환되는 어댑터 클래스를 활용해서 서비스와 통신할 수 있다. 간단한 예시를 보이면 다음과 같다.

예를 들어 어떤 Xml 객체를 출력하는 인터페이스를 클라이언트가 다음처럼 구현하고 있다고 해 보자.
```java
// CLIENT
public class LegacyWriter implements XmlWriter {
    @Override
    public String write(Xml xml) {
        return String.format("<%s>%s</%s>", xml.tag, xml.value, xml.tag);
    }
}
```
이 클라이언트는 Xml 클래스만 받기 때문에 Json 클래스를 출력할 수 없다. 대신 Json 클래스를 출력할 수 있는 서비스는 다음처럼 정의되어 있다.
```java
// SERVICE
public class LatestWriter {
    public String write(Json json) {
        return String.format("{%s:'%s'}", json.key, json.value);
    }
}
```

이 두 클래스를 수정하지 않고 연결하려면 다음처럼 어댑터 클래스를 작성할 수 있다.
```java
public class WriterAdapter implements XmlWriter {
    private final LatestWriter jsonWriter;

    public WriterAdapter(LatestWriter jsonWriter) {
        this.jsonWriter = jsonWriter;
    }

    @Override
    public String write(Xml xml) {
        Json convertedJson = new Json(xml.tag, xml.value);
        return jsonWriter.write(convertedJson);
    }
}
```
언급했듯이 클라이언트의 인터페이스(`XmlWriter`)를 구현하면서 서비스 객체(`LatestWriter`)를 포함하여 두 클래스를 연결해서 사용하는 것을 볼 수 있다. 
그럼 클라이언트 코드(개발자) 측에서는 다음처럼 사용할 수 있다.
```java
public class Main {
    public static void main(String[] args) {
        LegacyWriter client = new LegacyWriter();
        Xml xml = new Xml("parameter", "username");
        System.out.println(client.write(xml));
        // service.write(xml); <-- incompatible.

        LatestWriter service = new LatestWriter();
        WriterAdapter adapter = new WriterAdapter(service);
        System.out.println(adapter.write(xml)); // <-- compatible by adapter.
    }
}
```
이 경우 출력값은 아래와 같다.
```
<parameter>username</parameter>
{parameter:'username'}
```
원하는 대로 두 클래스의 수정 없이 연결한 것을 볼 수 있다.

## 프록시 패턴
프록시 패턴은 원본 객체에 대한 접근을 제어하는 디자인 패턴이다. 클라이언트 측에서는 프록시 객체와 원본 객체를 구분할 수 없어야 하며 요청, 응답은 원본 객체와 동일해야 한다.
이를 위해서 원본 객체의 인터페이스를 분리해서 프록시 객체가 구현하는 방식을 활용할 수 있다.
![image](https://refactoring.guru/images/patterns/diagrams/proxy/structure-2x.png)

프록시 패턴은 여러 장점이 있는데 단순히 객체에 대한 접근을 제어하는 것 뿐 아니라 객체 호출 전후에 특별한 비즈니스 로직을 추가할 수도 있고 초기화에 시간이 오래 걸리는 자원은
실제 호출 시 lazy하게 초기화하도록 미룰 수도 있다. 아니면 한 번 접근했던 데이터는 다음 접근 시 캐싱을 활용해서 효율적으로 활용할 수 있다.
그러면서도 원본 객체는 변할 필요가 없는 OCP가 이 프록시 패턴의 장점이라 할 수 있다.
```java
public class SecretData implements DataRetrievable {
    @Override
    public String getData(String connection) {
        return "SENSITIVE_DATA";
    }
}
```
예를 들어 민감한 정보를 반환하는 객체가 있다고 하자. 이 객체에 대한 접근을 기록하기 위해 기능을 추가하려면 해당 클래스를 변경하는 것이 처음 떠오르는 해결 방법이지만
역시 OCP를 준수하려면 여기서 프록시 객체를 생성해서 사용할 수 있다.
```java
public class SecretDataProxy implements DataRetrievable {
    private final SecretData data;

    public SecretDataProxy(SecretData data) {
        this.data = data;
    }

    @Override
    public String getData(String connection) {
        System.out.printf("Secret data accessed at %s%n", LocalDateTime.now());
        String data = this.data.getData(connection);
        System.out.printf("Secret data retrieved at %s%n", LocalDateTime.now());
        return data;
    }
}
```
클라이언트 코드에서는 다음처럼 프록시 객체를 원본 객체와 동일하게 다룰 수 있다.
```java
public class Main {
    public static void main(String[] args) {
        DataRetrievable proxiedData = new SecretDataProxy(new SecretData());
        System.out.println(proxiedData.getData("jdbc_url_here"));
        System.out.println("");

        DataRetrievable normalData = new SecretData();
        System.out.println(normalData.getData("jdbc_url_here"));
    }
}
```
실행 결과는 다음과 같다.
```
Secret data accessed at 2021-11-01T12:36:57.267611700
Secret data retrieved at 2021-11-01T12:36:57.286611700
SENSITIVE_DATA

SENSITIVE_DATA
```
프록시 객체와 원본 객체 둘 다 `DataRetrievable` 인터페이스로 동일하게 사용했지만 프록시 객체는 추가된 로깅 기능이 적용된 것을 볼 수 있다.

상속으로 비슷하게 해결할 수 있는 문제가 아닌가 싶기도 하지만 프록시 패턴은 원본 객체의 전체적인 생명 주기를 관리하는 구성(composition) 방식을 사용하며 
lazy 초기화나 캐싱같은 문제는 상속이 해결할 수 없다는 차이가 있다.

위의 코드에서는 클라이언트가 직접 원본 객체를 생성해서 프록시 객체로 전달하는 방식을 사용했지만 실제로는 프록시 객체가 직접 원본 객체를 생성하는 방식을 사용할 수도 있다.
프록시 패턴과 유사한 데코레이터 패턴과의 가장 큰 차이점이 바로 이 점인데 데코레이터 패턴은 항상 클라이언트가 객체를 생성해서 주입시키는 방식이다.
[링크1](https://refactoring.guru/design-patterns/proxy), [링크2](https://stackoverflow.com/questions/18618779/differences-between-proxy-and-decorator-pattern/60478875)

## 데코레이터 패턴
데코레이터 패턴은 원본 객체를 감싸는 다른 객체를 만들어서 기능을 덧붙여가는 방식으로 추가하는 디자인 패턴이다. 프록시 패턴과 다른점은 프록시 객체는 원본 객체의 응답값을 건드리지 않지만
데코레이터 패턴에서는 기능 추가로 인해 충분히 변경될 수 있다는 점이다.
![image](https://refactoring.guru/images/patterns/diagrams/decorator/structure-2x.png)

프록시 패턴처럼 이 데코레이터 객체를 사용하는 클라이언트 측에서는 얼마나 많은 데코레이터 객체로 원본 객체가 감싸져 있던 간에 동일한 원본 객체처럼 다룰 수 있어야 한다. 
이 점이 일반 래퍼 클래스와 데코레이터 클래스의 차이점이며 이를 구현하기 위해 자바의 인터페이스를 활용할 수 있다.
```java
public class SimplePrinter implements Printer {
    @Override
    public String print(String name) {
        return name;
    }
}
```
단순한 문자열을 출력하는 `Printer` 인터페이스가 있을 때 원본 객체 `SimplePrinter`는 이를 구현하여 문자열을 반환하고 있다.
```java
public class SimplePrinter implements Printer {
    @Override
    public String print(String name) {
        return name;
    }
}
```
이 `SimplePrinter`를 꾸미는 데코레이터 클래스는 다음처럼 `Printer` 인터페이스를 구현하고 꾸밀 원본 객체(또는 데코레이터 객체)에 대한 참조를 내부 필드에 보관하는 식으로 디자인할 수 있다.
```java
import java.time.LocalDateTime;

public class TimeStampDecorator implements Printer {
    private final Printer printer;

    public TimeStampDecorator(Printer printer) {
        this.printer = printer;
    }

    @Override
    public String print(String name) {
        String innerResult = printer.print(name);
        return String.format("%s: %s", LocalDateTime.now(), innerResult);
    }
}
```
```java
public class NameDecorator implements Printer {
    private final Printer printer;

    public NameDecorator(Printer printer) {
        this.printer = printer;
    }

    @Override
    public String print(String name) {
        String innerResult = printer.print(name);
        return String.format("%s the Great", innerResult);
    }
}
```
```java
public class GreetingDecorator implements Printer {
    private final Printer printer;

    public GreetingDecorator(Printer printer) {
        this.printer = printer;
    }

    @Override
    public String print(String name) {
        String innerResult = printer.print(name);
        return String.format("Hello, %s!", innerResult);
    }
}
```
이런 식으로 디자인한 후 클라이언트 코드에서 다음처럼 적용시키면 데코레이터 클래스의 기능이 원본 객체에 중첩되서 적용된 것을 볼 수 있다.
```java
public class Main {
    public static void main(String[] args) {
        String name = "Kwonkyu";
        Printer simplePrinter = new SimplePrinter();
        Printer nameDecorator = new NameDecorator(simplePrinter);
        Printer greetDecorator = new GreetingDecorator(nameDecorator);
        Printer timestampDecorator = new TimeStampDecorator(greetDecorator);

        System.out.println(timestampDecorator.print(name));
        System.out.println(greetDecorator.print(name));
        System.out.println(nameDecorator.print(name));
        System.out.println(simplePrinter.print(name));
    }
}
```
실행 결과는 다음과 같다.
```
2021-11-01T14:20:57.201488600: Hello, Kwonkyu the Great!
Hello, Kwonkyu the Great!
Kwonkyu the Great        
Kwonkyu
```
필요에 따라 데코레이터 클래스를 추가하거나 삭제하는 것으로 객체의 기능을 유연하게 변경할 수 있으며 이는 고정된 부모 클래스의 기능을 가지는 상속과 구성(composition)의 차이점이라 할 수 있다.
역시 원본 클래스를 변경할 필요 없이 기능을 추가할 수 있기 때문에 OCP를 준수한다.

## 싱글턴 패턴
